1. [EchoClient]
package h2;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.net.InetSocketAddress;

// 클라이언트를 초기화하기 위한 부트스트랩 인스턴스를 생성한다.
// 새로운 연결을 생성하고 인바운드와 아웃바운드 데이터를 처리하는 것을 포함하는 이벤트 처리를 제어할 루프 그룹 인스턴스를 만들고 할당한다.
// 서버로 연결하기 위한 인터넷소켓주소를 생성한다
// 연결이 만들어지면 파이프라인에 에코클라이언트핸들러 하나를 추가한다.
// 부트스트랩 연결을 하여 원격서버로 연결

public class EchoClient {
public EchoClient(){
}

public void start() throws Exception {
    EventLoopGroup group = new NioEventLoopGroup();
    try {
        Bootstrap b = new Bootstrap();  // bootstrap 생성
        b.group(group)  // 클라이언트 이벤트 처리할 EventLoopGroup을 지정.
                .channel(NioSocketChannel.class)    // 채널 유형 NIO 지정
                .remoteAddress(new InetSocketAddress(8888)) // 서버의 InetSocketAddress를 설정
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {    // 채널이 생성될 때 파이프라인에 EchoClientHandler 하나를 추가
                        ch.pipeline().addLast(new EchoClientHandler());
                    }
                });
        ChannelFuture f = b.connect().sync();   // 원격 피어로 연결하고 연결이 완료되기를 기다림
        f.channel().closeFuture().sync();   // 채널이 닫힐 때까지 블로킹함.
    } finally {
        group.shutdownGracefully().sync();  // 스레드 풀을 종료하고 모든 리소스를 해제함
    }
}

public static void main(String[] args) throws Exception {
    new EchoClient().start();
}
}
------------------------------------------------------------------------------------------------------------------------------
2.[EchoClientHandler]
package h2;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.util.CharsetUtil;

// 채널액티브 : 서버에 대한 연결이 만들어지면 호출된다
// 채널읽기 : 서버로부터 메시지를 수신하면 호출된다
// 예외
@ChannelHandler.Sharable
public class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {

@Override
public void channelActive(ChannelHandlerContext ctx) throws Exception {
    ctx.writeAndFlush(Unpooled.copiedBuffer("Netty Connect()", CharsetUtil.UTF_8)); // 채널 활성화 시 메시지 전송
}

@Override
public void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
    System.out.println("Client receive : " + msg.toString(CharsetUtil.UTF_8));  // 수신한 메시지 로깅
}

@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    cause.printStackTrace();    // 예외 시 오류를 로깅하고 채널 닫기
    ctx.close();
}
}
------------------------------------------------------------------------------------------------------------------------------
3.[EchoServer]

package h2;

import java.net.InetSocketAddress;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
// 서버의 부트스트랩을 진행
// 서버가 수신할 포트를 바인딩하고 들어오는 연결 요청을 수락한다
// 에코서버핸들러 인스턴스에 인바운드 메시지에 대해 알리도록 채널을 구성한다.
public class EchoServer {
    private final int port;
 
    public EchoServer() {
        this.port = 8888;
    }
 
    public static void main(String[] args) throws Exception {
        new EchoServer().start();   // 서버의 start() 메소드 호출
    }
 
    private void start() throws Exception {
        final EchoServerHandler serverHandler = new EchoServerHandler();
        EventLoopGroup group = new NioEventLoopGroup(); // EventLoopGroup 생성
        try {
            ServerBootstrap b = new ServerBootstrap();  // ServerBootstrap 생성
            b.group(group)
                    .channel(NioServerSocketChannel.class)  // NIO 전송채널을 이용하도록 지정
                    .localAddress(new InetSocketAddress(port))  // 지정된 포트로 소켓 주소 설정
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception { // EchoServerHandler 하나를 채널의 Channel Pipeline 으로 추가
                            ch.pipeline().addLast(serverHandler);
                        }
                    });
            ChannelFuture f = b.bind().sync();  // 서버를 비동기식으로 바인딩
            f.channel().closeFuture().sync();   // 채널의 CloseFuture를 얻고 완료될 때까지 현재 스레드를 블로킹
        } finally {
            group.shutdownGracefully().sync();  // EventLoopGroup을 종료하고 모든 리소스 해제
        }
    }
}
------------------------------------------------------------------------------------------------------------------------------
4.[EchoServerHandler]

package h2;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

// 서버로 들어오는 메시지에 반응해야 하므로 인바운드 이벤트에 반응하는 매서드가 정의된 channelinboundhandler인터페이스를 구현해야 한다.
// channelRead : 메시지가 들어올 때마다 호출된다.
//channelReadComplete: 채널읽기 의 마지막 호출에서 현재 일괄 처리의 마지막 메시지를 처리했음을 핸들러에 통보한다.
//
@ChannelHandler.Sharable
public class EchoServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf in = (ByteBuf)msg;
        System.out.println("Server received : " + in.toString(CharsetUtil.UTF_8));
        ctx.write(in); // 받은 메시지를 발신자에게로 Echo 시킨다.
    }
 
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Bye");
        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) // 대기중인 메시지를 플러시하고 채널을 닫음
                .addListener(ChannelFutureListener.CLOSE);
    }
 
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();	// 채널 닫기
    }
}



------------------------------------------------------------------------------------------------------------------------------

참고 : https://javacoding.tistory.com/144
